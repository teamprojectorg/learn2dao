{"ast":null,"code":"import { bytes as binary, CID } from './index.js';\nconst readonly = function () {\n  let {\n    enumerable = true,\n    configurable = false\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    enumerable,\n    configurable,\n    writable: false\n  };\n};\nconst links = function* (source, base) {\n  if (source == null) return;\n  if (source instanceof Uint8Array) return;\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key];\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index];\n          const cid = CID.asCID(element);\n          if (cid) {\n            yield [elementPath.join('/'), cid];\n          } else if (typeof element === 'object') {\n            yield* links(element, elementPath);\n          }\n        }\n      } else {\n        const cid = CID.asCID(value);\n        if (cid) {\n          yield [path.join('/'), cid];\n        } else {\n          yield* links(value, path);\n        }\n      }\n    }\n  }\n};\nconst tree = function* (source, base) {\n  if (source == null) return;\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key];\n    yield path.join('/');\n    if (value != null && !(value instanceof Uint8Array) && typeof value === 'object' && !CID.asCID(value)) {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [...path, index];\n          yield elementPath.join('/');\n          if (typeof element === 'object' && !CID.asCID(element)) {\n            yield* tree(element, elementPath);\n          }\n        }\n      } else {\n        yield* tree(value, path);\n      }\n    }\n  }\n};\nconst get = (source, path) => {\n  let node = source;\n  for (const [index, key] of path.entries()) {\n    node = node[key];\n    if (node == null) {\n      throw new Error(`Object has no property at ${path.slice(0, index + 1).map(part => `[${JSON.stringify(part)}]`).join('')}`);\n    }\n    const cid = CID.asCID(node);\n    if (cid) {\n      return {\n        value: cid,\n        remaining: path.slice(index + 1).join('/')\n      };\n    }\n  }\n  return {\n    value: node\n  };\n};\nclass Block {\n  constructor(_ref) {\n    let {\n      cid,\n      bytes,\n      value\n    } = _ref;\n    if (!cid || !bytes || typeof value === 'undefined') throw new Error('Missing required argument');\n    this.cid = cid;\n    this.bytes = bytes;\n    this.value = value;\n    this.asBlock = this;\n    Object.defineProperties(this, {\n      cid: readonly(),\n      bytes: readonly(),\n      value: readonly(),\n      asBlock: readonly()\n    });\n  }\n  links() {\n    return links(this.value, []);\n  }\n  tree() {\n    return tree(this.value, []);\n  }\n  get() {\n    let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';\n    return get(this.value, path.split('/').filter(Boolean));\n  }\n}\nconst encode = async _ref2 => {\n  let {\n    value,\n    codec,\n    hasher\n  } = _ref2;\n  if (typeof value === 'undefined') throw new Error('Missing required argument \"value\"');\n  if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher');\n  const bytes = codec.encode(value);\n  const hash = await hasher.digest(bytes);\n  const cid = CID.create(1, codec.code, hash);\n  return new Block({\n    value,\n    bytes,\n    cid\n  });\n};\nconst decode = async _ref3 => {\n  let {\n    bytes,\n    codec,\n    hasher\n  } = _ref3;\n  if (!bytes) throw new Error('Missing required argument \"bytes\"');\n  if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher');\n  const value = codec.decode(bytes);\n  const hash = await hasher.digest(bytes);\n  const cid = CID.create(1, codec.code, hash);\n  return new Block({\n    value,\n    bytes,\n    cid\n  });\n};\nconst createUnsafe = _ref4 => {\n  let {\n    bytes,\n    cid,\n    value: maybeValue,\n    codec\n  } = _ref4;\n  const value = maybeValue !== undefined ? maybeValue : codec && codec.decode(bytes);\n  if (value === undefined) throw new Error('Missing required argument, must either provide \"value\" or \"codec\"');\n  return new Block({\n    cid,\n    bytes,\n    value\n  });\n};\nconst create = async _ref5 => {\n  let {\n    bytes,\n    cid,\n    hasher,\n    codec\n  } = _ref5;\n  if (!bytes) throw new Error('Missing required argument \"bytes\"');\n  if (!hasher) throw new Error('Missing required argument \"hasher\"');\n  const value = codec.decode(bytes);\n  const hash = await hasher.digest(bytes);\n  if (!binary.equals(cid.multihash.bytes, hash.bytes)) {\n    throw new Error('CID hash does not match bytes');\n  }\n  return createUnsafe({\n    bytes,\n    cid,\n    value,\n    codec\n  });\n};\nexport { encode, decode, create, createUnsafe, Block };","map":{"version":3,"names":["bytes","binary","CID","readonly","enumerable","configurable","writable","links","source","base","Uint8Array","key","value","Object","entries","path","Array","isArray","index","element","elementPath","cid","asCID","join","tree","get","node","Error","slice","map","part","JSON","stringify","remaining","Block","constructor","asBlock","defineProperties","split","filter","Boolean","encode","codec","hasher","hash","digest","create","code","decode","createUnsafe","maybeValue","undefined","equals","multihash"],"sources":["/Users/yuchenpeng/dao_terminal_v0/node_modules/multiformats/esm/src/block.js"],"sourcesContent":["import {\n  bytes as binary,\n  CID\n} from './index.js';\nconst readonly = ({enumerable = true, configurable = false} = {}) => ({\n  enumerable,\n  configurable,\n  writable: false\n});\nconst links = function* (source, base) {\n  if (source == null)\n    return;\n  if (source instanceof Uint8Array)\n    return;\n  for (const [key, value] of Object.entries(source)) {\n    const path = [\n      ...base,\n      key\n    ];\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [\n            ...path,\n            index\n          ];\n          const cid = CID.asCID(element);\n          if (cid) {\n            yield [\n              elementPath.join('/'),\n              cid\n            ];\n          } else if (typeof element === 'object') {\n            yield* links(element, elementPath);\n          }\n        }\n      } else {\n        const cid = CID.asCID(value);\n        if (cid) {\n          yield [\n            path.join('/'),\n            cid\n          ];\n        } else {\n          yield* links(value, path);\n        }\n      }\n    }\n  }\n};\nconst tree = function* (source, base) {\n  if (source == null)\n    return;\n  for (const [key, value] of Object.entries(source)) {\n    const path = [\n      ...base,\n      key\n    ];\n    yield path.join('/');\n    if (value != null && !(value instanceof Uint8Array) && typeof value === 'object' && !CID.asCID(value)) {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [\n            ...path,\n            index\n          ];\n          yield elementPath.join('/');\n          if (typeof element === 'object' && !CID.asCID(element)) {\n            yield* tree(element, elementPath);\n          }\n        }\n      } else {\n        yield* tree(value, path);\n      }\n    }\n  }\n};\nconst get = (source, path) => {\n  let node = source;\n  for (const [index, key] of path.entries()) {\n    node = node[key];\n    if (node == null) {\n      throw new Error(`Object has no property at ${ path.slice(0, index + 1).map(part => `[${ JSON.stringify(part) }]`).join('') }`);\n    }\n    const cid = CID.asCID(node);\n    if (cid) {\n      return {\n        value: cid,\n        remaining: path.slice(index + 1).join('/')\n      };\n    }\n  }\n  return { value: node };\n};\nclass Block {\n  constructor({cid, bytes, value}) {\n    if (!cid || !bytes || typeof value === 'undefined')\n      throw new Error('Missing required argument');\n    this.cid = cid;\n    this.bytes = bytes;\n    this.value = value;\n    this.asBlock = this;\n    Object.defineProperties(this, {\n      cid: readonly(),\n      bytes: readonly(),\n      value: readonly(),\n      asBlock: readonly()\n    });\n  }\n  links() {\n    return links(this.value, []);\n  }\n  tree() {\n    return tree(this.value, []);\n  }\n  get(path = '/') {\n    return get(this.value, path.split('/').filter(Boolean));\n  }\n}\nconst encode = async ({value, codec, hasher}) => {\n  if (typeof value === 'undefined')\n    throw new Error('Missing required argument \"value\"');\n  if (!codec || !hasher)\n    throw new Error('Missing required argument: codec or hasher');\n  const bytes = codec.encode(value);\n  const hash = await hasher.digest(bytes);\n  const cid = CID.create(1, codec.code, hash);\n  return new Block({\n    value,\n    bytes,\n    cid\n  });\n};\nconst decode = async ({bytes, codec, hasher}) => {\n  if (!bytes)\n    throw new Error('Missing required argument \"bytes\"');\n  if (!codec || !hasher)\n    throw new Error('Missing required argument: codec or hasher');\n  const value = codec.decode(bytes);\n  const hash = await hasher.digest(bytes);\n  const cid = CID.create(1, codec.code, hash);\n  return new Block({\n    value,\n    bytes,\n    cid\n  });\n};\nconst createUnsafe = ({\n  bytes,\n  cid,\n  value: maybeValue,\n  codec\n}) => {\n  const value = maybeValue !== undefined ? maybeValue : codec && codec.decode(bytes);\n  if (value === undefined)\n    throw new Error('Missing required argument, must either provide \"value\" or \"codec\"');\n  return new Block({\n    cid,\n    bytes,\n    value\n  });\n};\nconst create = async ({bytes, cid, hasher, codec}) => {\n  if (!bytes)\n    throw new Error('Missing required argument \"bytes\"');\n  if (!hasher)\n    throw new Error('Missing required argument \"hasher\"');\n  const value = codec.decode(bytes);\n  const hash = await hasher.digest(bytes);\n  if (!binary.equals(cid.multihash.bytes, hash.bytes)) {\n    throw new Error('CID hash does not match bytes');\n  }\n  return createUnsafe({\n    bytes,\n    cid,\n    value,\n    codec\n  });\n};\nexport {\n  encode,\n  decode,\n  create,\n  createUnsafe,\n  Block\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}